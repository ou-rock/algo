# 算法可视化工具使用指南

<div align="center">

![Algorithm Visualization](https://img.shields.io/badge/Algorithm-Visualization-blue)
![Python](https://img.shields.io/badge/Python-3.7+-green)
![HTML5](https://img.shields.io/badge/HTML5-Interactive-orange)
![License](https://img.shields.io/badge/License-MIT-yellow)

**让算法学习更直观、更有趣!**

</div>

---

## 📖 目录

- [项目简介](#项目简介)
- [功能特点](#功能特点)
- [支持的算法](#支持的算法)
- [使用方法](#使用方法)
  - [方式一: HTML版本 (推荐)](#方式一-html版本-推荐)
  - [方式二: Python版本](#方式二-python版本)
- [算法详解](#算法详解)
- [截图展示](#截图展示)
- [技术栈](#技术栈)
- [贡献指南](#贡献指南)

---

## 🎯 项目简介

本项目提供了一套完整的**算法可视化工具**,帮助学习者直观理解各种经典算法的执行过程。通过动画演示,你可以清楚地看到算法的每一步操作,包括:

- 🔄 元素比较
- 🔀 元素交换
- 📍 指针移动
- ✅ 已排序/已处理部分

无论是学生、教师还是程序员,都可以通过这个工具更好地理解算法原理。

---

## ✨ 功能特点

### 🎨 交互式可视化
- **实时动画**: 观察算法的每一步执行过程
- **可控速度**: 调整动画播放速度,慢速学习或快速演示
- **步进模式**: 逐步执行,仔细观察每个步骤
- **自定义数据**: 输入自己的测试数据

### 📊 详细统计
- **步骤计数**: 显示当前步骤和总步骤数
- **比较次数**: 记录算法进行了多少次比较
- **交换次数**: 记录元素交换的次数
- **时间复杂度**: 每个算法都标注了时间复杂度

### 🎨 颜色编码
- 🔵 **蓝色**: 未处理的元素
- 🟠 **橙色**: 正在比较的元素
- 🔴 **红色**: 刚刚交换的元素
- 🟢 **绿色**: 已完成/已排序的元素
- 🟡 **黄色**: 特殊标记(如最小值指针)
- 🟣 **紫色**: 插入操作的元素

---

## 🧮 支持的算法

### 1️⃣ 排序算法

#### 🫧 冒泡排序 (Bubble Sort)
- **时间复杂度**: O(n²)
- **空间复杂度**: O(1)
- **稳定性**: 稳定
- **适用场景**: 小规模数据、教学演示

**工作原理**: 重复遍历数组,比较相邻元素并交换,直到整个数组有序。

#### 📥 插入排序 (Insertion Sort)
- **时间复杂度**: O(n²)
- **空间复杂度**: O(1)
- **稳定性**: 稳定
- **适用场景**: 小规模数据、部分有序数据

**工作原理**: 将数组分为已排序和未排序两部分,每次从未排序部分取一个元素插入到已排序部分的正确位置。

#### 🔍 选择排序 (Selection Sort)
- **时间复杂度**: O(n²)
- **空间复杂度**: O(1)
- **稳定性**: 不稳定
- **适用场景**: 小规模数据

**工作原理**: 每次从未排序部分选择最小元素,放到已排序部分的末尾。

### 2️⃣ 搜索算法

#### 🎯 二分查找 (Binary Search)
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)
- **前提条件**: 数组必须有序

**工作原理**: 在有序数组中,每次将搜索范围缩小一半,快速定位目标元素。

### 3️⃣ 基础算法

#### 📈 查找最大值 (Find Maximum)
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

**工作原理**: 遍历数组,维护当前最大值,最终找到全局最大值。

#### ➕ 数组求和 (Array Sum)
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

**工作原理**: 遍历数组,累加所有元素得到总和。

---

## 🚀 使用方法

### 方式一: HTML版本 (推荐)

**最简单的方式,无需安装任何依赖!**

#### 步骤:

1. **打开文件**
   ```bash
   # 直接在浏览器中打开
   open algorithm_visualizer.html
   # 或者在Windows上
   start algorithm_visualizer.html
   # 或者直接双击文件
   ```

2. **使用界面**
   - 📝 在"输入数据"框中输入要可视化的数据(用逗号分隔)
     - 示例: `64, 34, 25, 12, 22, 11, 90`
   - 🎲 或点击"随机数据"按钮生成随机数据
   - 🎯 选择要演示的算法(点击对应按钮)
   - ⚡ 调整动画速度(慢 ← → 快)
   - ▶️ 点击"开始"播放动画
   - ⏸️ 点击"暂停"暂停动画
   - ⏭️ 点击"下一步"单步执行
   - 🔄 点击"重置"回到初始状态

3. **特别说明**
   - 对于**二分查找**,还需要输入目标值
   - 动画会自动循环播放
   - 实时显示比较次数、交换次数等统计信息

#### 特性:
- ✅ 无需安装任何软件
- ✅ 跨平台(Windows/Mac/Linux)
- ✅ 精美的UI界面
- ✅ 完全交互式控制
- ✅ 支持所有现代浏览器

---

### 方式二: Python版本

**适合需要更深入定制或学习Python动画编程的用户**

#### 安装依赖:

```bash
# 安装matplotlib
pip install matplotlib

# 或使用conda
conda install matplotlib
```

#### 运行程序:

```bash
# 进入python目录
cd python

# 运行可视化工具
python algorithm_visualization.py
```

#### 使用说明:

程序会依次展示以下算法的可视化:
1. 冒泡排序
2. 插入排序
3. 选择排序
4. 二分查找
5. 查找最大值
6. 数组求和

**操作**:
- 关闭当前窗口会自动显示下一个算法
- 按 `Ctrl+C` 可以随时中断演示

#### 自定义使用:

你也可以在代码中自定义测试数据:

```python
from algorithm_visualization import SortingVisualizer, SearchVisualizer

# 自定义数据
my_data = [45, 12, 78, 34, 56, 23, 89]

# 创建可视化器
visualizer = SortingVisualizer(my_data)

# 运行冒泡排序可视化
anim = visualizer.bubble_sort_visualize()

# 显示动画
import matplotlib.pyplot as plt
plt.show()
```

#### 高级用法:

```python
# 保存动画为GIF
from matplotlib.animation import PillowWriter

visualizer = SortingVisualizer([64, 34, 25, 12, 22, 11])
anim = visualizer.bubble_sort_visualize()

# 保存为GIF
writer = PillowWriter(fps=1)
anim.save('bubble_sort.gif', writer=writer)
```

---

## 📚 算法详解

### 冒泡排序的执行过程

以数组 `[5, 2, 8, 1, 9]` 为例:

```
第1轮:
[5, 2, 8, 1, 9]  比较5和2 → 交换
[2, 5, 8, 1, 9]  比较5和8 → 不交换
[2, 5, 8, 1, 9]  比较8和1 → 交换
[2, 5, 1, 8, 9]  比较8和9 → 不交换
[2, 5, 1, 8, 9]  最大值9已就位

第2轮:
[2, 5, 1, 8, 9]  比较2和5 → 不交换
[2, 5, 1, 8, 9]  比较5和1 → 交换
[2, 1, 5, 8, 9]  比较5和8 → 不交换
[2, 1, 5, 8, 9]  次大值8已就位

... 继续直到完全排序 ...

最终结果: [1, 2, 5, 8, 9]
```

### 二分查找的执行过程

在有序数组 `[1, 3, 5, 7, 9, 11, 13, 15]` 中查找 `7`:

```
初始: low=0, high=7
[1, 3, 5, 7, 9, 11, 13, 15]
          ↑
     mid=3, arr[3]=7
     找到! 返回索引3
```

如果查找 `11`:

```
第1步: low=0, high=7, mid=3, arr[3]=7
       7 < 11, 在右半部分查找

第2步: low=4, high=7, mid=5, arr[5]=11
       找到! 返回索引5
```

---

## 🖼️ 截图展示

### HTML可视化界面

```
┌────────────────────────────────────────────┐
│  🎯 算法可视化工具                          │
│  Algorithm Visualization Tool               │
└────────────────────────────────────────────┘

┌─ 选择算法 ──────────────────────────────────┐
│ [冒泡排序] [插入排序] [选择排序]             │
│ [二分查找] [查找最大值] [数组求和]           │
└────────────────────────────────────────────┘

┌─ 输入数据 ──────────────────────────────────┐
│ 64, 34, 25, 12, 22, 11, 90                  │
└────────────────────────────────────────────┘

┌─ 可视化区域 ────────────────────────────────┐
│                                             │
│     █    █    █    █    █    █    █         │
│    90   64   34   25   22   12   11         │
│                                             │
│  当前步骤: 正在比较 64 和 34                 │
└────────────────────────────────────────────┘

┌─ 统计信息 ──────────────────────────────────┐
│ 当前步骤: 5/42  |  比较: 3  |  交换: 1       │
└────────────────────────────────────────────┘
```

---

## 🛠️ 技术栈

### HTML版本
- **HTML5**: 页面结构
- **CSS3**: 渐变、动画、响应式设计
- **JavaScript (ES6+)**: 算法实现和Canvas绘图
- **Canvas API**: 图形绘制

### Python版本
- **Python 3.7+**: 核心语言
- **Matplotlib**: 数据可视化和动画
- **NumPy**: 数值计算(可选)

---

## 📖 代码示例

### 如何添加新的排序算法可视化

```python
def custom_sort_visualize(self):
    """自定义排序算法可视化"""
    self.steps = []
    arr = self.data.copy()

    # 记录初始状态
    self.steps.append({
        'array': arr.copy(),
        'comparing': [],
        'sorted': [],
        'description': '初始状态'
    })

    # 实现你的排序算法
    # 在关键步骤记录状态到 self.steps

    # 记录最终状态
    self.steps.append({
        'array': arr.copy(),
        'sorted': list(range(len(arr))),
        'description': '排序完成!'
    })

    return self._create_animation('自定义排序')
```

---

## 🎓 学习建议

1. **从简单开始**: 先理解简单算法(求和、最大值)
2. **对比学习**: 比较不同排序算法的执行过程
3. **调整速度**: 遇到难以理解的地方,放慢速度仔细观察
4. **自定义数据**: 尝试不同的输入数据,观察算法表现
5. **记录笔记**: 边看边记录关键步骤

### 推荐学习路径

```
1. 基础算法
   ├─ 数组求和 (理解遍历)
   └─ 查找最大值 (理解比较)

2. 简单排序
   ├─ 冒泡排序 (理解交换)
   ├─ 选择排序 (理解选择)
   └─ 插入排序 (理解插入)

3. 高效查找
   └─ 二分查找 (理解分治)

4. 扩展学习
   ├─ 快速排序
   ├─ 归并排序
   └─ 堆排序
```

---

## 🤝 贡献指南

欢迎贡献!你可以:

1. 🐛 报告Bug
2. 💡 提出新功能建议
3. 📝 改进文档
4. 🎨 优化UI设计
5. ➕ 添加新的算法可视化

### 如何贡献

```bash
# 1. Fork 本仓库
# 2. 创建特性分支
git checkout -b feature/new-algorithm

# 3. 提交更改
git commit -m "添加堆排序可视化"

# 4. 推送到分支
git push origin feature/new-algorithm

# 5. 创建 Pull Request
```

---

## 📊 项目统计

- **支持算法**: 6+ 个经典算法
- **代码行数**: 1000+ 行
- **可视化步骤**: 动态生成
- **浏览器兼容**: Chrome, Firefox, Safari, Edge

---

## 📄 许可证

MIT License - 自由使用、修改和分发

---

## 🙏 致谢

- 感谢《数据结构和算法之美》专栏提供的算法实现参考
- 感谢开源社区的支持和贡献
- 感谢所有使用本工具学习算法的朋友们

---

## 📞 联系方式

如有问题或建议,欢迎:
- 提交 Issue
- 发起 Pull Request
- 在讨论区交流

---

<div align="center">

**⭐ 如果这个项目对你有帮助,请给一个星标!**

Made with ❤️ and ☕

</div>
